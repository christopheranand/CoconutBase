-- |
-- Module      :  Coconut.Utils.CGWrappers
-- Copyright   :  (c) OCA 2021
-- License     :  MIT (see the LICENSE file)
-- Maintainer  :  curtis.dalves@gmail.com
-- Stability   :  provisional
-- Portability :  experimental
--
-- This module exports functionality for encoding Coconut DSL's using @CodeGraph@'s from
-- @CoconutHypergraph@ with auxillary data types encoding Edge Labels and their results
-- (i.e., @EL@ and @ResType@)

{-# LANGUAGE TypeFamilies, TypeApplications, ScopedTypeVariables, AllowAmbiguousTypes, FlexibleContexts, FlexibleInstances, ExistentialQuantification,GADTs, TemplateHaskell #-}
{-# LANGUAGE TupleSections,BangPatterns #-}
module Coconut.Utils.CGWrappers where

import qualified Data.List as List
import Data.Word (Word64)
import qualified Data.Map.Strict as Map
import Data.Typeable
import GHC.TypeNats (KnownNat)
import Data.Maybe (fromJust)

import Data.ByteString.Char8 (ByteString)
import qualified Data.ByteString.Char8 as BC
import Data.ByteString.Short (ShortByteString)
import qualified Data.ByteString.Short as BS

import Control.Monad ((<$!>))
import Control.Monad.State.Strict (gets,get)
import Control.DeepSeq 

import Data.Graph.Inductive.Graph (Node)

import Coconut.BaseTypes
import Coconut.Graph.DataFlow
import Coconut.Graph.ControlFlow
import Coconut.Graph.CodeGraph
import Coconut.Graph.ByteStringAST
import Data.Graph.Inductive (graphNodes)
import Debug.Trace (traceM)
import GHC.TypeLits
import Coconut.Core.CoreISA -- (CoreISA(jump))
import Coconut.Core.Interp hiding (nat)

import Coconut.Utils.CGWrappersTH

import Debug.Trace

pupd f g (x,y) = (f x, g y)
curry3 :: ((a, b, c) -> d) -> (a -> b -> c -> d)
curry3 f a b c = f (a, b, c)

curry4 :: ((a, b, c, d) -> e) -> (a -> b -> c -> d -> e)
curry4 f a b c d =  f (a, b, c, d)

nat :: forall n. (KnownNat n) => Int
nat = fromIntegral $ natVal (Proxy :: Proxy n)

singleOnly _ _ [x] = x
singleOnly f l [] = error ("singleOnly [] at " ++ f ++ ":" ++ show l)
singleOnly f l _ = error ("singleOnly [_,_,...] at " ++ f ++ ":" ++ show l)

{- |Unwrappable h class

   A class representing an intermediate form of a codegraph that can both be wrapped up in a
   value of type `a` and unwrapped from a value of type `a`. This used as a basis for the types
   of inputs and outputs that our instructions can have.
-}
class Unwrappable h a where
  -- | Unwraps the phantom parameter (i.e. Unwrapped (Graph h a) becomes just a)
  type Unwrapped a
  -- | A function to wrap a list of CGMState types into a type `a`.
  wrap :: [(CGBState h Node,ShortByteString,Maybe ShortByteString)] -> a
  -- | A function to unwrap the type `a` to a list of CGMState types.
  unwrap :: a -> [(CGBState h Node,ShortByteString,Maybe ShortByteString)]
  -- | A string representing the Unwrappable object.
  idStr :: String -- TODO do we need this, is this and nodeType redundant?
  -- | The list of ResTypes associated with this 'Unwrappable' thing
  nodeType :: [ResType h]

instance Hardware h => Unwrappable h () where
  type Unwrapped () = ()
  wrap _ = ()
  unwrap _ = []
  idStr = ""
  nodeType = [EmptyRes]

-- These instances are automatically generated by TH
-- Uncomment for development purposes
{-
instance (Unwrappable h a,Unwrappable h b) => Unwrappable h (a,b) where
  type Unwrapped (a,b) = (Unwrapped a,Unwrapped b)
  wrap xs = case xs of
    [a,b] -> (wrap [a],wrap [b])
    _ -> error $ "Unwrappable.wrap list length mismatch, expected length 2 got length: " ++ show (length xs)
  unwrap (a,b) = concat [unwrap a, unwrap b]
  idStr = idStr @h @a ++ idStr @h @b
  nodeType = nodeType @h @a ++ nodeType @h @b

instance(Unwrappable h a, Unwrappable h b, Unwrappable h c) =>
        Unwrappable h (a, b, c) where
  type Unwrapped (a,b,c) = (Unwrapped a,Unwrapped b,Unwrapped c)
  wrap xs = case xs of
    [a, b, c] -> (wrap [a], wrap [b], wrap [c])
    _ -> error $ "Unwrappable.wrap list length mismatch, expected length 3 got length: " ++ show (length xs)
  unwrap (a, b, c) = concat [unwrap a, unwrap b, unwrap c]
  idStr = idStr @h @a ++ idStr @h @b ++ idStr @h @c
  nodeType = nodeType @h @a ++ nodeType @h @b ++ nodeType @h @c

instance (Unwrappable h a, Unwrappable h b, Unwrappable h c, Unwrappable h d) =>
         Unwrappable h (a, b, c, d) where
  type Unwrapped (a,b,c,d) = (Unwrapped a,Unwrapped b,Unwrapped c,Unwrapped d)
  wrap xs = case xs of
    [a,b,c,d] -> (wrap [a], wrap [b], wrap [c], wrap [d])
    _ -> error $ "Unwrappable.wrap list length mismatch, expected length 4 got length: " ++ show (length xs)
  unwrap (a, b, c, d) = concat [unwrap a, unwrap b, unwrap c, unwrap d]
  idStr = idStr @h @a ++ idStr @h @b ++ idStr @h @c ++ idStr @h @d
  nodeType = nodeType @h @a ++ nodeType @h @b ++ nodeType @h @c ++ nodeType @h @d

instance (Unwrappable h a1, Unwrappable h a2, Unwrappable h a3, Unwrappable h a4
         ,Unwrappable h a5, Unwrappable h a6, Unwrappable h a7, Unwrappable h a8
         ,Unwrappable h a9, Unwrappable h a10, Unwrappable h a11, Unwrappable h a12
         ,Unwrappable h a13, Unwrappable h a14, Unwrappable h a15, Unwrappable h a16
         ,Unwrappable h a17, Unwrappable h a18, Unwrappable h a19, Unwrappable h a20
         ,Unwrappable h a21, Unwrappable h a22, Unwrappable h a23, Unwrappable h a24
         ,Unwrappable h a25) =>
         Unwrappable h (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16,
                  a17, a18, a19, a20, a21, a22, a23, a24, a25) where
  type Unwrapped (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16,
                  a17, a18, a19, a20, a21, a22, a23, a24, a25) =
    (Unwrapped a1, Unwrapped a2, Unwrapped a3, Unwrapped a4, Unwrapped a5
    ,Unwrapped a6, Unwrapped a7, Unwrapped a8, Unwrapped a9, Unwrapped a10
    ,Unwrapped a11, Unwrapped a12, Unwrapped a13, Unwrapped a14, Unwrapped a15
    ,Unwrapped a16, Unwrapped a17, Unwrapped a18, Unwrapped a19, Unwrapped a20
    ,Unwrapped a21, Unwrapped a22, Unwrapped a23, Unwrapped a24, Unwrapped a25)
  wrap xs = case xs of
    [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16,
                  a17, a18, a19, a20, a21, a22, a23, a24, a25] ->
      (wrap [a1], wrap [a2], wrap [a3], wrap [a4], wrap [a5]
      ,wrap [a6], wrap [a7], wrap [a8], wrap [a9], wrap [a10]
      ,wrap [a11], wrap [a12], wrap [a13], wrap [a14], wrap [a15]
      ,wrap [a16], wrap [a17], wrap [a18], wrap [a19], wrap [a20]
      ,wrap [a21], wrap [a22], wrap [a23], wrap [a24], wrap [a25])
  unwrap (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16,
                  a17, a18, a19, a20, a21, a22, a23, a24, a25) =
    concat [unwrap a1, unwrap a2, unwrap a3, unwrap a4, unwrap a5
           ,unwrap a6, unwrap a7, unwrap a8, unwrap a9, unwrap a10
           ,unwrap a11, unwrap a12, unwrap a13, unwrap a14, unwrap a15
           ,unwrap a16, unwrap a17, unwrap a18, unwrap a19, unwrap a20
           ,unwrap a21, unwrap a22, unwrap a23, unwrap a24, unwrap a25]
  idStr = idStr @h @a1 ++ idStr @h @a2 ++ idStr @h @a3 ++ idStr @h @a4 ++ idStr @h @a5 ++
          idStr @h @a6 ++ idStr @h @a7 ++ idStr @h @a8 ++ idStr @h @a9 ++ idStr @h @a10 ++
          idStr @h @a11 ++ idStr @h @a12 ++ idStr @h @a13 ++ idStr @h @a14 ++ idStr @h @a15 ++
          idStr @h @a16 ++ idStr @h @a17 ++ idStr @h @a18 ++ idStr @h @a19 ++ idStr @h @a20 ++
          idStr @h @a21 ++ idStr @h @a22 ++ idStr @h @a23 ++ idStr @h @a24 ++ idStr @h @a25
  nodeType = nodeType @h @a1 ++ nodeType @h @a2 ++ nodeType @h @a3 ++ nodeType @h @a4 ++ nodeType @h @a5 ++
          nodeType @h @a6 ++ nodeType @h @a7 ++ nodeType @h @a8 ++ nodeType @h @a9 ++ nodeType @h @a10 ++
          nodeType @h @a11 ++ nodeType @h @a12 ++ nodeType @h @a13 ++ nodeType @h @a14 ++ nodeType @h @a15 ++
          nodeType @h @a16 ++ nodeType @h @a17 ++ nodeType @h @a18 ++ nodeType @h @a19 ++ nodeType @h @a20 ++
          nodeType @h @a21 ++ nodeType @h @a22 ++ nodeType @h @a23 ++ nodeType @h @a24 ++ nodeType @h @a25
-}

$(generateNUnwrappableTuples 25)
$(generateNTupleData 25)

-- TODO can we generalize these Unwrappable instances?
result :: forall x. Typeable x => TypeRep
result = typeRep (Proxy @x)

instance Hardware h => Unwrappable h (Graph h GPR) where
  type Unwrapped (Graph h GPR) = GPR
  wrap xs = case xs of
    [(g,s,ms)] -> Graph g s ms
    _ -> error $ "Unwrappable.wrap list length mismatch, expected length 1 got length: " ++ show (length xs)
  unwrap (Graph g s ms) = [(g,s,ms)]
  idStr = "G"
  nodeType = [RegisterRes $ typeToReg $ result @GPR]

instance Hardware h => Unwrappable h (Graph h FPR) where
  type Unwrapped (Graph h FPR) = FPR
  wrap xs = case xs of
    [(g,s,ms)] -> Graph g s ms
    _ -> error $ "Unwrappable.wrap list length mismatch, expected length 1 got length: " ++ show (length xs)
  unwrap (Graph g s ms) = [(g,s,ms)]
  idStr = "F"
  nodeType = [RegisterRes $ typeToReg $ result @FPR]

instance Hardware h => Unwrappable h (Graph h VR) where
  type Unwrapped (Graph h VR) = VR
  wrap xs = case xs of
    [(v,s,ms)] -> Graph v s ms
    _ -> error $ "Unwrappable.wrap list length mismatch, expected length 1 got length: " ++ show (length xs)
  unwrap (Graph v s ms) = [(v,s,ms)]
  idStr = "V"
  nodeType = [RegisterRes $ typeToReg $ result @VR]

instance Hardware h => Unwrappable h (Graph h CR) where
  type Unwrapped (Graph h CR) = CR
  wrap xs = case xs of
    [(c,s,ms)] -> Graph c s ms
    _ -> error $ "Unwrappable.wrap list length mismatch, expected length 1 got length: " ++ show (length xs)
  unwrap (Graph c s ms) = [(c,s,ms)]
  idStr = "C"
  nodeType = [RegisterRes $ typeToReg $ result @CR]

instance Hardware h => Unwrappable h (Graph h MR) where
  type Unwrapped (Graph h MR) = MR
  wrap xs = case xs of
    [(m,s,ms)] -> Graph m s ms
    _ -> error $ "Unwrappable.wrap list length mismatch, expected length 1 got length: " ++ show (length xs)
  unwrap (Graph m s ms) = [(m,s,ms)]
  idStr = "M"
  nodeType = [MemoryRes 0] -- TODO: Figure out where to get the size

instance Hardware h => Unwrappable h (Graph h SPILL) where
  type Unwrapped (Graph h SPILL) = SPILL
  wrap xs = case xs of
    [(m,s,ms)] -> Graph m s ms
    _ -> error $ "Unwrappable.wrap list length mismatch, expected length 1 got length: " ++ show (length xs)
  unwrap (Graph m s ms) = [(m,s,ms)]
  idStr = "S"
  nodeType = [SpillRes] 

instance Hardware h => Unwrappable h (Graph h BRANCH) where
  type Unwrapped (Graph h BRANCH) = BRANCH
  wrap xs = case xs of
    [(b,s,ms)] -> Graph b s ms
    _ -> error $ "Unwrappable.wrap list length mismatch, expected length 1 got length: " ++ show (length xs)
  unwrap (Graph b s ms) = [(b,s,ms)]
  idStr = "B"
  nodeType = []

instance Show (Graph h GPR) where
  show _ = "Graph h GPR"

instance Show (Graph h VR) where
  show _ = "Graph h VR"

instance Show (Graph h FPR) where
  show _ = "Graph h FPR"

instance Show (Graph h CR) where
  show _ = "Graph h CR"

instance Show (Graph h MR) where
  show _ = "Graph h MR"

{- |A possible output type for an instruction.

    Make something an instance of 'Output' in order to specify that this type can be the
    output of an instruction. In most cases, the 'wrapper' function should be generated for
    you automatically.
-}
class (Unwrappable h b) => Output h b where
  wrapper :: ShortByteString -> CGBState h [Node] -> b
  wrapper !lbl = force $ wrap . (:[]) . (,lbl,Nothing) . fmap (singleOnly (idStr @h @b) ())

-- singleOnly _ _ [x] = x
-- singleOnly f l [] = error ("singleOnly [] at " ++ f ++ ":" ++ show l)
-- singleOnly f l _ = error ("singleOnly [_,_,...] at " ++ f ++ ":" ++ show l)

instance (NFData a,NFData b,Output h a, Output h b) => Output h (a, b) where
  wrapper !lbl n =
    let
      n0 = fmap (take 1) n
      n1 = fmap (drop 1) n
    in (wrapper (force $ buildASTParams lbl 0) n0
       ,wrapper (force $ buildASTParams lbl 1) n1)

instance (NFData a,NFData b,NFData c,Output h a, Output h b,Output h c) => Output h (a, b, c) where
  wrapper !lbl n =
    let
      n0 = fmap (take 1) n
      n1 = fmap (take 1 . drop 1) n
      n2 = fmap (drop 2) n
    in (wrapper (force $ buildASTParams lbl 0) n0
       ,wrapper (force $ buildASTParams lbl 1) n1
       ,wrapper (force $ buildASTParams lbl 2) n2)

instance (NFData a,NFData b,NFData c,NFData d,Output h a, Output h b,Output h c,Output h d)
   => Output h (a, b, c,d) where
  wrapper !lbl n =
    let
      n0 = fmap (take 1) n
      n1 = fmap (take 1 . drop 1) n
      n2 = fmap (take 1 . drop 2) n
      n3 = fmap (drop 3) n
    in (wrapper (force $ buildASTParams lbl 0) n0
       ,wrapper (force $ buildASTParams lbl 1) n1
       ,wrapper (force $ buildASTParams lbl 2) n2
       ,wrapper (force $ buildASTParams lbl 3) n3)

-- | Construct a String encoded AST that can be used to uniquely identify
-- nodes in a Graph for sharing
-- buildStringAST :: DFNode h -> [ByteString] -> ByteString
-- buildStringAST !dfNode !inpLbls =
--   let
--     opLbl :: ByteString
--     !opLbl = case dfNode of
--               (InstructionNode (Instruction imm name _) ) -> (BC.pack name)<>"_("<>(BC.pack $! show imm)<>")"
--               -- TODO how to handle initmr tables
--               (InstructionNode (InitMR name _) ) -> "initMR_"<>(BC.pack $! name)
--               (InstructionNode Meet) -> "meet"
--               (InstructionNode Join) -> "join"
--               (BranchNode name imm _) -> (BC.pack $! name)<>"_("<>(BC.pack $! show imm)<>")"
--               (ResourceNode _) -> error "buildStringAST given ResourceNode"
--     !inpLbls' = map (\s -> "("<>s<>")") inpLbls
--   in force $ BC.intercalate "_" $! opLbl:inpLbls'

-- TODO enumerate more Output tuple instances

instance Hardware h => Output h (Graph h GPR)
instance Hardware h => Output h (Graph h VR)
instance Hardware h => Output h (Graph h CR)
instance Hardware h => Output h (Graph h FPR)
instance Hardware h => Output h (Graph h BRANCH)
instance Hardware h => Output h (Graph h MR)
instance Hardware h => Output h (Graph h SPILL)

{- |A class representing a pair of 'Unwrappable' things, the second of which is
    also an 'Output'. If you have an instance like 'MakeOp h a b', then it is possible
    for an operation (instruction) to have an input type 'a' and an output type 'b'.
    This is represented by the `op1` function.

    For example, if you have the instance `MakeOp (VR GRAPH) (VR GRAPH)`, then one
    legal input and output type for an instruction is VR GRAPH -> VR GRAPH.
-}
class (Unwrappable h a, Unwrappable h b, Output h b,Hardware h) => MakeOp h a b where
  {- | The `op1` function respresents an instruction with a string name and a list of 'Word64'
       inputs, and some input type (e.g. a register) @a@, and produces a register type @b@.
  -}
  op1 :: (Eq (RegType h),Show (RegType h)) => EL h -> a -> b
  op1 el inputs = {-# SCC "op1" #-}
    let
      inputs' = unwrap $! inputs
      !inpLbls = map (\(_,l,_) -> l) inputs'
      !ast = force $ buildByteStringAST (InstructionNode el) inpLbls
    in wrapper ast $ do
        unInputs <- cgbSequence inputs'
        (instrNode,outNodes) <- cgbAddInstructionIfNew unInputs el (nodeType @h @b)
        cgbCacheOutputs outNodes ast
        return outNodes

  {- | The `op_o1` is the same as the `op1` function but specifies a vector input that is
       overwritten to an output (i.e. (o0,o1) means non-constant input at index
       o0 is overwritten to output at index o1)
  -}
  op_o1 :: (Eq (RegType h),Show (RegType h),Hardware h) => EL h -> (Int,Int) -> a -> b
  op_o1 el (o0,o1) inputs = {-# SCC "op_o1" #-}
    let
      inputs' = unwrap $! inputs
      !inpLbls = map (\(_,lbl,_) -> lbl) inputs'
      !ast = force $ buildByteStringAST (InstructionNode el) inpLbls
    in wrapper ast $ do
        unInputs <- cgbSequence $ inputs'
        -- need to detect if input being overwritten has already been used by overwriting instruction
        cgbState <- get
        let curOverwrites = dfbOverwrites $ cgbDFBuilder cgbState
        let alreadyOverwritten = (unInputs !! o0) `elem` map (fst . snd) curOverwrites
        maybeDuplicate <- cgbCheckIfOverwriteIsDuplicate unInputs el (nodeType @h @b)
        inpIsConstant <- cgbInputIsConstantLoad (unInputs !! o0)
        if alreadyOverwritten
          then case maybeDuplicate of
                  Nothing -> case inpIsConstant of
                               -- when the overwritten input is not a constant load, use a copy instruction
                               Nothing ->
                                 do (instrNodeV,outNodesV) <-
                                      let
                                        resType = (nodeType @h @a) !! o0
                                        regType = case resType of
                                                    RegisterRes rt -> rt
                                                    _ -> error $ "non-reg node being overwritten"
                                        in cgbAddInstruction [unInputs !! o0]
                                                              (Move (moveName regType) True)
                                                              [(nodeType @h @a) !! o0]
                                    (instrNode,outNodes) <- cgbAddInstructionIfNew
                                                            [ if idx == o0
                                                              then head outNodesV
                                                              else x | (x,idx) <- zip unInputs [0..] ]
                                                            el (nodeType @h @b)
                                    cgbAddOverwrite (instrNode,(head outNodesV,outNodes !! o1))
                                    return outNodes
                               -- when the overwritten input is a constant load, simply reload
                               Just constEL ->
                                 do (instrNodeL,outNodesL) <- cgbAddInstruction
                                                                [] constEL [(nodeType @h @a) !! o0]
                                    (instrNode,outNodes) <- cgbAddInstructionIfNew
                                                            [ if idx == o0
                                                              then head outNodesL
                                                              else x | (x,idx) <- zip unInputs [0..] ]
                                                            el (nodeType @h @b)
                                    cgbAddOverwrite (instrNode,(head outNodesL,outNodes !! o1))
                                    cgbCacheOutputs outNodes ast
                                    return outNodes
                  Just outs -> return outs
          else do (instrNode,outNodes) <- cgbAddInstructionIfNew unInputs el (nodeType @h @b)
                  cgbAddOverwrite (instrNode,(unInputs !! o0, outNodes !! o1))
                  cgbCacheOutputs outNodes ast
                  return outNodes

  {- | The `op_m1` is the same as the `op_o1` function but specifies a memory input that is
       overwritten to a memory output (i.e. (o0,o1) means non-constant input as index
       o0 is overwritten to output at index o1)
  -}
  op_m1 :: (Eq (RegType h),Show (RegType h),Hardware h) => EL h -> (Int,Int) -> a -> b
  op_m1 el (o0,o1) inputs = {-# SCC "op_m1" #-}
    let
      inputs' = unwrap $! inputs
      !inpLbls = map (\(_,lbl,_) -> lbl) inputs'
      !ast = force $ buildByteStringAST (InstructionNode el) inpLbls
    in wrapper ast $ do
         unInputs <- cgbSequence $ inputs'
         (instrNode,outNodes) <- cgbAddInstructionIfNew unInputs el (nodeType @h @b)
         cgbAddOverwrite (instrNode,(unInputs !! o0, outNodes !! o1))
         cgbCacheOutputs outNodes ast
         return outNodes

  {- | The `op_d1` is the same as the `op1` function but it used to designate
       instructions that have no outputs (like jumps/branches)
  -}
  op_d1 :: (Eq (RegType h),Show (RegType h), Hardware h) => DFNode h -> a -> b
  op_d1 bn inputs = {-# SCC "op_d1"  #-}
    let
      inputs' = unwrap $! inputs
      !inpLbls = map (\(_,lbl,_) -> lbl) inputs'
      !ast = force $ buildByteStringAST bn inpLbls
    in wrapper ast $ do
      unInputs <- cgbSequence $ inputs'
      (instrNode,outNodes) <- cgbAddDFNodeWithInputsIfNew unInputs bn
      cgbCacheOutputs outNodes ast
      return outNodes

  {- | The `op_c1` is the same as the `op1` function but it used to designate
       instructions that are constant loads
  -}
  op_c1 :: (Eq (RegType h),Show (RegType h), Hardware h) => EL h -> (Word64,Word64) -> a -> b
  op_c1 el c inputs = {-# SCC "op_c1" #-}
    let
      inputs' = unwrap $! inputs
      !inpLbls = map (\(_,lbl,_) -> lbl) inputs'
      !ast = force $ buildByteStringAST (InstructionNode el) inpLbls
    in wrapper ast $ do
        unInputs <- cgbSequence $ inputs'
        (instrNode,outNodes) <- cgbAddInstructionIfNew unInputs el (nodeType @h @b)
        cgbAddConstant c
        cgbCacheOutputs outNodes ast
        return outNodes

instance (Unwrappable h a,Unwrappable h b, Output h b, Hardware h) => MakeOp h a b

-- | An operation with no inputs
op0 :: (MakeOp h () b,Eq (RegType h),Show (RegType h)) => EL h -> b
op0 el = op1 el ()

-- | An operation with two inputs
op2 :: (MakeOp h (a, b) c,Eq (RegType h),Show (RegType h)) => EL h -> a -> b -> c
op2 el = curry $ op1 el

-- | An operation with three inputs
op3 :: (MakeOp h (a, b, c) d,Eq (RegType h),Show (RegType h)) => EL h -> a -> b -> c -> d
op3 el = curry3 $ op1 el

-- | An operation with four inputs
op4 :: (MakeOp h (a, b, c, d) e,Eq (RegType h),Show (RegType h)) => EL h -> a -> b -> c -> d -> e
op4 el = curry4 $ op1 el

-- | Just like @op0@ but designates the instruction as a jump
op_d0 :: (MakeOp h () b,Eq (RegType h),Show (RegType h),Hardware h) => DFNode h -> b
op_d0 el = op_d1 el ()

-- | Just like @op2@ but designates the instruction as a jump
op_d2 :: (MakeOp h (a, b) c,Eq (RegType h),Show (RegType h),Hardware h) => DFNode h -> a -> b -> c
op_d2 el = curry $ op_d1 el

-- | Just like @op3@ but designates the instruction as a jump
op_d3 :: (MakeOp h (a, b, c) d,Eq (RegType h),Show (RegType h),Hardware h) => DFNode h -> a -> b -> c -> d
op_d3 el = curry3 $ op_d1 el

-- | Just like @op4@ but designates the instruction as a jump
op_d4 :: (MakeOp h (a, b, c, d) e,Eq (RegType h),Show (RegType h),Hardware h) => DFNode h -> a -> b -> c -> d -> e
op_d4 el = curry4 $ op_d1 el

-- | Just like @op0@ but specifies overwrites
op_o0 :: (MakeOp h () b,Eq (RegType h),Show (RegType h),Hardware h) => EL h -> (Int,Int) -> b
op_o0 el os = op_o1 el os ()

-- | Just like @op2@ but specifies overwrites
op_o2 :: (MakeOp h (a, b) c,Eq (RegType h),Show (RegType h),Hardware h) => EL h -> (Int,Int) -> a -> b -> c
op_o2 el os = curry $ op_o1 el os

-- | Just like @op3@ but specifies overwrites
op_o3 :: (MakeOp h (a, b, c) d,Eq (RegType h),Show (RegType h),Hardware h) => EL h -> (Int,Int) -> a -> b -> c -> d
op_o3 el os = curry3 $ op_o1 el os

-- | Just like @op4@ but specifies overwrites
op_o4 :: (MakeOp h (a, b, c, d) e,Eq (RegType h),Show (RegType h),Hardware h) => EL h -> (Int,Int) -> a -> b -> c -> d -> e
op_o4 el os = curry4 $ op_o1 el os

-- | Just like @op0@ but specifies overwrites
op_m0 :: (MakeOp h () b,Eq (RegType h),Show (RegType h),Hardware h) => EL h -> (Int,Int) -> b
op_m0 el os = op_m1 el os ()

-- | Just like @op2@ but specifies overwrites
op_m2 :: (MakeOp h (a, b) c,Eq (RegType h),Show (RegType h),Hardware h) => EL h -> (Int,Int) -> a -> b -> c
op_m2 el os = curry $ op_m1 el os

-- | Just like @op3@ but specifies overwrites
op_m3 :: (MakeOp h (a, b, c) d,Eq (RegType h),Show (RegType h),Hardware h) => EL h -> (Int,Int) -> a -> b -> c -> d
op_m3 el os = curry3 $ op_m1 el os

-- | Just like @op4@ but specifies overwrites
op_m4 :: (MakeOp h (a, b, c, d) e,Eq (RegType h),Show (RegType h),Hardware h) => EL h -> (Int,Int) -> a -> b -> c -> d -> e
op_m4 el os = curry4 $ op_m1 el os

-- | Just like @op0@ but designates a constant load
op_c0 :: (MakeOp h () b,Eq (RegType h),Show (RegType h),Hardware h) => EL h -> (Word64,Word64) -> b
op_c0 el c = op_c1 el c ()

-- | Generate a @Block@
-- Takes a label and @Graph@ combinator, generates a corresponding @DataFlowGraph@ and creates
-- a @CFDataFlow@ edge with a single input and output CFNode in the "in-construction" @ControlFlowGraph@
-- NOTE curried combinators are not currently supported, use (Graph VR, Graph VR) -> Graph VR
-- instead of Graph VR -> Graph VR -> Graph VR
basicBlock :: forall h a b . (NFData a,NFData b,Unwrappable h a,Unwrappable h b,Show a, Show (RegType h),Hardware h) -- FIXME Show a only added for debugging
  => String -> [String] -> [String] -> (a -> b) -> Block h (Unwrapped a,Unwrapped b)
basicBlock label inTags outTags f =
  let
    -- TODO enforce inputs have unique names?
    inputList :: [(String,ResType h )]
    !inputList = traceShowId $ zip inTags $ nodeType @h @a

    createInputs :: [(CGBState h Node,ShortByteString,Maybe ShortByteString)]
    !createInputs = map (\(lbl,res) -> (cgbAddInput (lbl,res),s2b lbl,Nothing)) inputList

    wrappedInputs :: a
    !wrappedInputs = traceShowId $ wrap createInputs

    unwrappedOutputs :: [(CGBState h Node,ShortByteString,Maybe ShortByteString)]
    !unwrappedOutputs = unwrap $ f wrappedInputs
  in Block $ do
    outs <- cgbSequence unwrappedOutputs
    cgbSetOutputs (zip outTags outs) (map (\(_,lbl,_) -> lbl) unwrappedOutputs)
    dfGraph <- cgbCreateDFGraph label
    -- add CFNodes and CFEdge
    let dfInputs = dataFlowInputs dfGraph
    let dfOutputs = dataFlowOutputs dfGraph
    cn0 <- cgbAddCFNode $ CFNode dfInputs
    cn1 <- cgbAddCFNode $ CFNode dfOutputs
    cgbAddCFEdge (cn0,cn1) (CFDataFlow label)
    cgbSetCFInsOuts (cn0,cn1)
    return $! BlockParams label cn0 dfInputs cn1 dfOutputs

-- | Create a @Block@ from a pre-existing @DataFlowGraph@ (will have to manually
-- cast the type)
dfGraphToBlock :: forall h a . Hardware h => String -> DataFlowGraph h -> Block h a
dfGraphToBlock label dfGraph =
  Block $ do
    dfGraph' <- cgbInsertDataFlow (label,dfGraph)
    let dfInputs' = dataFlowInputs dfGraph'
        dfOutputs' = dataFlowOutputs dfGraph'
    c0 <- cgbAddCFNode $ CFNode dfInputs'
    c1 <- cgbAddCFNode $ CFNode dfOutputs'
    cgbAddCFEdge (c0,c1) (CFDataFlow label)
    return $! BlockParams label c0 dfInputs' c1 dfOutputs'

-- | Generate a @BranchBlock@
-- Same as @basicBlock@ but specifies a condition register
-- NOTE curried combinators are not currently supported, use (Graph VR, Graph VR) -> (Graph CR,Graph VR)
-- instead of Graph VR -> Graph VR -> (Graph CR, Graph VR )
branchingBlock :: forall h a b . (Hardware h,NFData a,NFData b, Unwrappable h a,Unwrappable h b)
  => String -> [String] -> [String] -> (a -> (Graph h BRANCH,b)) -> BranchBlock h (Unwrapped a,Unwrapped b)
branchingBlock label inTags outTags f =
  let
    inputList :: [(String,ResType h)]
    inputList = zip inTags $ nodeType @h @a

    createInputs :: [(CGBState h Node,ShortByteString,Maybe ShortByteString)]
    createInputs = map (\(lbl,res) -> (cgbAddInput (lbl,res),s2b lbl,Nothing)) inputList

    wrappedInputs :: a
    wrappedInputs = wrap createInputs

    unwrappedOutputs :: [(CGBState h Node,ShortByteString,Maybe ShortByteString)]
    unwrappedOutputs = unwrap $ f wrappedInputs
  in BranchBlock $ do
    -- Set outputs and generate data flow graph
    outs <- cgbSequence unwrappedOutputs
    cgbSetOutputs (zip outTags outs) (map (\(_,lbl,_) -> lbl) unwrappedOutputs)
    dfGraph <- cgbCreateDFGraph label
    -- add CFNodes and CFEdge
    let dfInputs = dataFlowInputs dfGraph
    let (branchNode:dfOutputs) = dataFlowOutputs dfGraph
    cn0 <- cgbAddCFNode $ CFNode dfInputs
    cn1 <- cgbAddCFNode $ CFBranchNode branchNode dfOutputs
    cgbAddCFEdge (cn0,cn1) (CFDataFlow label)
    cgbSetCFInsOuts (cn0,cn1)
    -- FIXME make sure this is the correct branch node somehow?
    return $ BranchBlockParams label branchNode cn0 dfInputs cn1 dfOutputs

-- | A @Block@ that uses a special @CFModuloBody@ edge instead of @CFDataFlow@
-- to mark the edge for modulo scheduling (NOTE @CodeGraph@'s generated with
-- this edge need to be refactored during scheduling and hence need to use a
-- special scheduling function like @moduloSchedule2S@)
moduloBlock :: forall h. (Hardware h)
  => String
  -> [String]
  -> [String]
  -> ((Graph h GPR,Graph h GPR,Graph h (MR),Graph h (MR))
      -> (Graph h GPR,Graph h GPR,Graph h (MR),Graph h (MR)))
  -> Block h ((GPR,GPR,MR,MR),(GPR,GPR,MR,MR))
moduloBlock label inTags outTags f =
  let
    inputList :: [(String,ResType h)]
    inputList = zip inTags $ nodeType @h @(Graph h GPR,Graph h GPR,Graph h (MR),Graph h (MR))

    createInputs :: [(CGBState h Node,ShortByteString,Maybe ShortByteString)]
    createInputs = map (\(lbl,res) -> (cgbAddInput (lbl,res),s2b lbl,Nothing)) inputList

    wrappedInputs :: (Graph h GPR,Graph h GPR,Graph h (MR),Graph h (MR))
    wrappedInputs = wrap createInputs

    unwrappedOutputs :: [(CGBState h Node,ShortByteString,Maybe ShortByteString)]
    unwrappedOutputs = unwrap $ f wrappedInputs
  in Block $ do
    -- Set outputs and generate data flow graph
    outs <- cgbSequence unwrappedOutputs
    cgbSetOutputs (zip outTags outs) (map (\(_,lbl,_) -> lbl) unwrappedOutputs)
    dfGraph <- cgbCreateDFGraph label
    let dfInputs = dataFlowInputs dfGraph
    let dfOutputs = dataFlowOutputs dfGraph
    cn0 <- cgbAddCFNode $ CFNode dfInputs
    cn1 <- cgbAddCFNode $ CFNode dfOutputs
    cgbAddCFEdge (cn0,cn1) (CFModuloBody label)
    cgbSetCFInsOuts (cn0,cn1)
    return $ BlockParams label cn0 dfInputs cn1 dfOutputs


-- | Turn a basic @Block@ into a @BranchBlock@ by adding an unconditional jump
-- (i.e. CoreISA jump instruction, which has instruction name "j")
blockAddJump :: forall h a b . Block h (a,b) -> BranchBlock h (a,b)
blockAddJump block = BranchBlock $ do
  bp <- genBlock block
  cgbState <- get
  let label = bpLabel bp
  let cfOut = bpCFOutput bp
  bNodeID <- cgbInsertDFNode label (BranchNode "jump" [] (jump @Interp))
  let bNode = (label++"_JUMP",bNodeID)
  let dfOutputs = bpDFOutputs bp
  let cfNode' = CFBranchNode bNode dfOutputs
  cfOut' <- cgbAddCFNode cfNode'
  cgbSubCFNode cfOut cfOut'
  return $ BranchBlockParams { bbpLabel = bpLabel bp
                             , bbpBranchNode = bNode
                             , bbpCFInput = bpCFInput bp
                             , bbpDFInputs = bpDFInputs bp
                             , bbpCFOutput = cfOut'
                             , bbpDFOutputs = bpDFOutputs bp
                             }

-- | Turn a @DataFlowGraph@ into a @BasicBlock@
basicBlockFromDF :: forall h a . Hardware h => String -> DataFlowGraph h -> Block h a
basicBlockFromDF label dfGraph =
  let
    dfInputs = dataFlowInputs dfGraph
    dfOutputs = dataFlowOutputs dfGraph
  in Block $ do
    dfGraph' <- cgbInsertDataFlow (label,dfGraph)
    cn0 <- cgbAddCFNode $ CFNode dfInputs
    cn1 <- cgbAddCFNode $ CFNode dfOutputs
    cgbAddCFEdge (cn0,cn1) (CFDataFlow label)
    return $ BlockParams label cn0 dfInputs cn1 dfOutputs
